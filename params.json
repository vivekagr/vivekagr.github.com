{"name":"Scala Basics","tagline":"","body":"Imperative Programming is about\r\n\r\n- modifying mutable variables,\r\n- using assignments\r\n- and control structures such as if-then-else, loops, breaks, continue, return.\r\n\r\nPure imperative programming is limited by the “Von Neumann” bottleneck:\r\n\r\n> One tends to conceptualize data structures word-by-word.\r\n\r\nWe need other techniques for deﬁning high-level abstractions such as collections, polynomials, geometric shapes, strings, documents.\r\n\r\nA theory consists of one or more data types, operation on these data types and laws that describe the relationship between values and operations.\r\n\r\nNormally, a theory doesn't describes mutations!\r\n\r\nFunctional Programming is about\r\n\r\n- In a restricted sense, it means programming without mutable variables, assignments, loops and other imperative control stuctures.\r\n- In a wider sense, functional programming means focusing on the functions to construct elegant programs.\r\n- In particular, functions can be values that are produced, consumed and composed.\r\n- Functions are first class citizens. They can be defined anywhere, including inside other functions.\r\n- Functions like any other value, passed as parameter to functions and returned as results. As for other values, there exists a set operators to compose\r\nfunctions.\r\n\r\nFunctional Programming is becoming increasingly popular because it oﬀers an attractive method for exploiting parallelism for multicore and cloud computing.\r\n\r\nIn a parallel environment, when multiple threads try to access and mutate a shared mutable state, problems arises. Though there are ways to solve it, it is not always easy and elegant as desired. In functional programming, by eliminating the use of mutable states these problems can be easily solved.\r\n\r\nFunctions can be defined as:\r\n\r\n\t::scala\r\n\tdef square(x: Double) = x * x\r\n\r\n\tdef sumOfSquares(x: Double, y: Double) = square(x) + square(y)\r\n\r\n\t/* Here, the return type is defined as well. */\r\n\tdef power(x: Double, y: Int): Double = ...\r\n\r\n\r\n**Call by value (CBV)** - All the arguments are evaluated to a simple value and then passed on to the function body as soon as the function is ran.\r\n\r\nExample:\r\n\t\r\n\t::scala\r\n\tdef example(x: Int, y: Int) = x * x\r\n\r\n\texample(2+3, 7)\r\n\r\n\t/*\r\n\tEvaluated as-\r\n\texample(2+3, 7) -> example(5, 7) -> 5 * 5 -> 25\r\n\t*/\r\n\r\n**Call by name (CBN)** - All the arguments are passed to the function body as it is and evaluation is done by the code within the function body.\r\n\r\nExample:\r\n\r\n\t::scala\r\n\texample(2+3, 7)\r\n\t\r\n\t/*\r\n\t * Evaluated as-\r\n\t * example(2+3, 7) -> (2+3) * (2+3) -> 5 * (2+3) -> 5 * 5 -> 25\r\n\t */\r\n\r\nIf CBV evaluation of an expression *e* terminates, then CBN evaluation of *e* terminates too.\r\n\r\nThe other direction is not true.\r\n\r\nNon-termination example\r\n\r\n\t::scala\r\n\tdef first(x: Int, y: Int) = x\r\n\r\n\tfirst(1, loop)\r\n\r\n\t/*\r\n\t * Here, the loop resolves to itself infinitely.\r\n\t * \r\n\t * Under CBN:\r\n\t * first(1, loop) -> 1\r\n\t * \r\n\t * Under CBV:\r\n\t * first(1, loop) -> first(1, loop) -> first(1, loop)....\r\n\t */\r\n\r\nScala normally uses call-by-value.\r\n\r\nBut if the type of a function parameter starts with =>, it uses call-by-name.\r\n\r\n\t::scala\r\n\tdef consOne(x: Int, y: => Int) = 1\r\n\r\n\t/* Here, x is evaluated as CBV by default and y is evaluated as CBN which we explicitly forced it to. */\r\n\r\n**Conditional Expressions**\r\n\r\nif-else in Scala is used for expressions, not statements.\r\n\r\n\t::scala\r\n\tdef abs(x: Int) = if (x >= 0) x else -x\r\n\r\nRewrite rules for Booleans (e is an arbitrary expression):\r\n\r\n\t::scala\r\n\t/* !true\t\t--> false\r\n\t * !false\t\t--> true\r\n\t * true && e \t--> e\r\n\t * false && e \t--> false\r\n\t * true || e \t--> true\r\n\t * false || e \t--> e\r\n\t */\r\n\r\n**Value Definitions**\r\n\r\nThe `def` form is \"by name\", its right hand side evaluated on each use.\r\n\r\nThere is also a `val` for, which is \"by value\". Example-\r\n\r\n\t::scala\r\n\tval x = 2\r\n\tval y = square(x)\r\n\r\nThe right hand side of a val definition is evaluated at the point of the definition itself.\r\n\r\nAfterwards the name refers to the value. Here y refers to 4, not square(2).\r\n\r\n**Difference between val and def**\r\n\r\nThe difference becomes apparent when the right hand side does not terminate.\r\n\r\n\t::scala\r\n\t/* This works fine. */\r\n\tdef loop: Boolean = loop\r\n\tdef x = loop\r\n\r\n\t/* However, this will get stuck in an infinite loop since the interpreter tries to evaluate the loop right at the point of definition. */\r\n\tval x = loop\r\n\r\n&& and || implementation as functions-\r\n\r\n\t::scala\r\n\tdef and(x: Boolean, y: => Boolean) = if (x) y else false\r\n\tdef or(x: Boolean, y: => Boolean) = if (!x) y else true\r\n\r\n**Return type is required when calling a function recursively.**\r\n\r\n**Blocks in Scala**\r\n\r\nA block is defined by curly braces {....}.\r\n\r\n\t::scala\r\n\t{\r\n\t\tval x = f(3)\r\n\t\tx * x\r\n\t}\r\n\r\nIt constains a sequence of definition or expressions.\r\nThe last element of a block is an expression that deﬁnes its value.\r\nThis return expression can be preceded by auxiliary deﬁnitions.\r\nBlocks are themselves expressions; a block may appear everywhere an expression can.\r\n\r\n- The deﬁnitions inside a block are only visible from within the block.\r\n- The deﬁnitions inside a block shadow deﬁnitions of the same names outside the block.\r\n\r\n**Semicolons**\r\n\r\nIn Scala, semicolons at the end of a line is optional in most cases. If there are more than one statements in one line, then they need to be separatd with a semi-colon.\r\n\r\n**Semicolons and inﬁx operators**\r\n\r\nOne issue with Scala’s semicolon convention is how to write expressions that span several lines. For instance-\r\n\r\n\t::scala\r\n\tsomeLongExpression\r\n\t+ someOtherExpression\r\n\r\n\t/* would be interpreted as */\r\n\r\n\tsomeLongExpression;\r\n\t+ someOtherExpression\r\n\r\nTwo ways to overcome the problem.\r\n\r\n\t::scala\r\n\t/* Multiline expression can be written inside parentheses. */\r\n\t(someLongExpression\r\n\t\t+ someOtherExpression)\r\n\r\n\t/* Or operator can be written on the first line because this tells the Scala compiler that the expression is not yet finished. */\r\n\tsomeLongExpression +\r\n\tsomeOtherExpression\r\n\r\n**Tail Recursion**\r\n\r\nIf a function calls itself as its last action, the function's stack frame can be reused. This is called tail recursion. Tail recursive functions are iterative processes.\r\n\r\nIn general, if the last action of a function consists of calling a function (which may be the same), one stack frame would be suﬃcient for both functions. Such calls are called tail-calls.\r\n\r\nExample of non-tail recursive factorial function:\r\n\r\n\t::scala\r\n\tdef factorial(x: Int): Int = \r\n\t\tif (x == 0) 1\r\n\t\telse x * factorial(x-1)\r\n\r\nExample of tail recursive factorial function:\r\n\r\n\t::scala\r\n\tdef factorial(x: Int) = \r\n\t\tdef fac_loop(accum: Int, n: Int): Int = \r\n\t\t\tif (n == 0) accum\r\n\t\t\telse fac_loop(accum * n, n - 1)\r\n\t\tloop(1, x)\r\n\r\nIn the first example, the return value `x * factorial(x-1)` has a pending calculation of x multiplied by factorial of (x-1) which would have to wait until that factorial has been computed and thus that recursive chain keeps on growing.\r\n\r\nHowever, in the second example, for the return value `fac_loop(accum * n, n - 1)` the function calls itself and there are no pending computation to be done, so the further function calls can take place in the same stack frame without growing like crazy like in the previous example.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}